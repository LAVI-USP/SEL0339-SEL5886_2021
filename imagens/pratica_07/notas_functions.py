# -*- coding: utf-8 -*-
"""notas_functions.py

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Gac-O7gwclL3Sq-kKKa8k5ir4smPJ490
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Oct 21 16:48:35 2020
@author: Rodrigo
"""

import numpy as np
import cv2 as cv

from imutils.perspective import four_point_transform
import imutils

class notas_Helper():
    
    def __init__(self):
        
        return
        
    def transformacao_perspectiva(self,img_rgb_in, img_gray_in, edges_in):
        
        edges = edges_in.copy()
        img_rgb = img_rgb_in.copy()
        img_gray = img_gray_in.copy()
        
        # find contours in the edge map, then initialize
        # the contour that corresponds to the document
        cnts = cv.findContours(edges.copy(), cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE)
        cnts = imutils.grab_contours(cnts)
        docCnt = None
        
        # ensure that at least one contour was found
        if len(cnts) > 0:
        	# sort the contours according to their size in
        	# descending order
        	cnts = sorted(cnts, key=cv.contourArea, reverse=True)
        
        	# loop over the sorted contours
        	for c in cnts:
        		# approximate the contour
        		peri = cv.arcLength(c, True)
        		approx = cv.approxPolyDP(c, 0.02 * peri, True)
        
        		# if our approximated contour has four points,
        		# then we can assume we have found the paper
        		if len(approx) == 4:
        			docCnt = approx
        			break
        
        # apply a four point perspective transform to both the
        # original image and grayscale image to obtain a top-down
        # birds eye view of the paper
        img_rgb_out = four_point_transform(img_rgb, docCnt.reshape(4, 2))
        img_gray_out = four_point_transform(img_gray, docCnt.reshape(4, 2))
        edges_out = four_point_transform(edges, docCnt.reshape(4, 2))
            
        return img_rgb_out, img_gray_out, edges_out
    
    def organizar_circulos(self,cx, cy, radii):
        
        sort_ind_Y = np.argsort(cy)
        
        sortedY = cy[sort_ind_Y]
        sortedX = cx[sort_ind_Y]
        sortedradii = radii[sort_ind_Y]
        
        inds = np.where(np.diff(sortedY) > 10)[0]
        
        YperLine = []
        XperLine = []
        radperLine = []
        init = 0
        final = 0
        for ind in inds:
          final = ind + 1
          YperLine.append(sortedY[init:final])
          XperLine.append(sortedX[init:final])
          radperLine.append(sortedradii[init:final])
          init = final
        YperLine.append(sortedY[init::])
        XperLine.append(sortedX[init::])
        radperLine.append(sortedradii[init::])
        YperLine = np.vstack(YperLine)
        XperLine = np.vstack(XperLine)
        radperLine = np.vstack(radperLine)
        
        sort_ind_X = np.argsort(XperLine, axis=1)
        
        for y_line in range(YperLine.shape[0]):
          YperLine[y_line,:] = YperLine[y_line,sort_ind_X[y_line,:]]
          XperLine[y_line,:] = XperLine[y_line,sort_ind_X[y_line,:]]
          radperLine[y_line,:] = radperLine[y_line,sort_ind_X[y_line,:]]
        
        cy_out = YperLine
        cx_out = XperLine
        radii_out = radperLine
        
        return cx_out, cy_out, radii_out